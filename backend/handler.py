from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton  # type: ignore
import re
from aiogram.filters.callback_data import CallbackData

class MessageCallback(CallbackData, prefix="recipe"):
    action: str
    id: str

class Handler:
    def __init__(self):
        self.user_data = {}  # Local dictionary to simulate user data storage
        self.recipes = {}  # Local dictionary to store recipes
        self.favorites = {}  # Local dictionary for favorite recipes

    async def get_recipe_history(self, user_id, offset: int = 0, limit: int = 3):
        """Get paginated recipe history for user from local storage"""
        user_recipes = self.recipes.get(user_id, [])
        has_more = len(user_recipes) > offset + limit
        return user_recipes[offset:offset + limit], has_more

    async def new_recipe_handler(self, user_id, recipe_data):
        product_links = {}
        total_cost = 0

        if 'links' in recipe_data:
            for category, products in recipe_data['links'].items():
                if category == "total_cost" or category == "message":
                    continue

                if not isinstance(products, list):
                    continue

                for product in products:
                    if not isinstance(product, dict):
                        continue

                    if 'message' in product:
                        product_links[category] = product['message']
                        continue

                    if product.get('name') and product.get('link'):
                        product_links[product['name']] = {
                            'link': product['link'],
                            'price': product.get('price', '–¶–µ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞')
                        }
                        if isinstance(product.get('price'), (int, float)):
                            total_cost += float(product['price'])

            product_links['total_cost'] = total_cost

            if "message" in recipe_data['links']:
                product_links['message'] = recipe_data['links']['message']

        recipe_id = len(self.recipes.get(user_id, [])) + 1
        recipe_entry = {
            "id": recipe_id,
            "request": recipe_data['request'],
            "text": recipe_data['text'],
            "ingredients": recipe_data['ingredients'],
            "product_links": product_links
        }
        self.recipes.setdefault(user_id, []).append(recipe_entry)
        return recipe_id

    async def format_recipe_with_links(self, recipe: dict) -> str:
        base_text = f"{recipe['text']}"

        if recipe.get('product_links'):
            base_text += "\n\n–°—Å—ã–ª–∫–∏ –Ω–∞ –ø—Ä–æ–¥—É–∫—Ç—ã:\n"

            portions_match = re.search(r'–Ω–∞ (\d+) –ø–æ—Ä—Ü–∏[—é–∏–µ]', recipe.get('request', ''))
            portions = portions_match.group(1) if portions_match else "1"

            for product_name, info in recipe['product_links'].items():
                if product_name in ['total_cost', 'message']:
                    continue

                base_text += f"\n{product_name.replace('+', ' ')}\n"
                if isinstance(info, str):
                    base_text += f"{info}\n"
                else:
                    base_text += f"–¶–µ–Ω–∞: {info.get('price', '–¶–µ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞')}\n"
                    base_text += f"–°—Å—ã–ª–∫–∞: {info.get('link', '–°—Å—ã–ª–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç')}\n"

            if 'total_cost' in recipe['product_links']:
                portions_in_russian = "–ø–æ—Ä—Ü–∏–π"
                if 2 <= int(portions) <= 4:
                    portions_in_russian = "–ø–æ—Ä—Ü–∏–∏"
                if int(portions) == 1:
                    portions_in_russian = "–ø–æ—Ä—Ü–∏—é"

                total_cost = float(recipe['product_links']['total_cost']) * int(portions)
                base_text += f"\nüí∞ –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–∞—è –∏—Ç–æ–≥–æ–≤–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –Ω–∞ {portions} {portions_in_russian}: {total_cost:.2f} RUB"

            if 'message' in recipe['product_links']:
                base_text += f"\n\n‚ö†Ô∏è {recipe['product_links']['message']}"

        return base_text

    async def toggle_favorite_recipe(self, user_id: int, recipe_id: str) -> bool:
        self.favorites.setdefault(user_id, set())
        if recipe_id in self.favorites[user_id]:
            self.favorites[user_id].remove(recipe_id)
            return False
        else:
            self.favorites[user_id].add(recipe_id)
            return True

    async def is_recipe_favorite(self, user_id: int, recipe_id: str) -> bool:
        return recipe_id in self.favorites.get(user_id, set())

    async def get_favorite_recipes(self, user_id: int) -> list:
        favorite_ids = self.favorites.get(user_id, set())
        return [recipe for recipe in self.recipes.get(user_id, []) if str(recipe['id']) in favorite_ids]

    async def get_recipe_by_id(self, recipe_id: str):
        for user_recipes in self.recipes.values():
            for recipe in user_recipes:
                if str(recipe['id']) == recipe_id:
                    return recipe
        return None

    async def add_new_user(self, user_id, user_name: str = "", language: str = "en"):
        self.user_data[user_id] = {"name": user_name, "language": language}

    async def get_user_preferences(self, user_id):
        return self.user_data.get(user_id, {})

    async def update_user_allergies(self, user_id: int, allergies: list):
        self.user_data.setdefault(user_id, {})['allergies'] = allergies

    async def update_price_limit(self, user_id: int, price_limit: int):
        self.user_data.setdefault(user_id, {})['max_price'] = price_limit

    async def update_disliked_products(self, user_id: int, disliked_products: list):
        self.user_data.setdefault(user_id, {})['unliked_products'] = disliked_products

    async def get_formatted_preferences(self, user_id: int) -> str:
        user_data = self.user_data.get(user_id, {})
        if not user_data:
            return "–ü—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã"

        allergies = user_data.get('allergies', [])
        allergies_text = "–ê–ª–ª–µ—Ä–≥–∏—è:\n" + "\n".join(allergies) if allergies else "–ê–ª–ª–µ—Ä–≥–∏—è:\n–ù–µ —É–∫–∞–∑–∞–Ω–æ"

        unliked = user_data.get('unliked_products', [])
        unliked_text = "\n\n–ù–µ–ª—é–±–∏–º—ã–µ –ø—Ä–æ–¥—É–∫—Ç—ã:\n" + "\n".join(unliked) if unliked else "\n\n–ù–µ–ª—é–±–∏–º—ã–µ –ø—Ä–æ–¥—É–∫—Ç—ã:\n–ù–µ —É–∫–∞–∑–∞–Ω–æ"

        price_text = f"\n\n–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ü–µ–Ω—ã:\n{user_data.get('max_price', '–ù–µ —É–∫–∞–∑–∞–Ω–æ')} —Ä—É–±."

        return allergies_text + unliked_text + price_text

    def create_recipe_keyboard(self, recipe_id: str, user_id: int, show_full=True) -> InlineKeyboardMarkup:
        is_favorite = self.is_recipe_favorite(user_id, recipe_id)
        favorite_text = "‚ùå –£–±—Ä–∞—Ç—å –∏–∑ –∏–∑–±—Ä–∞–Ω–Ω–æ–≥–æ" if is_favorite else "‚≠êÔ∏è –î–æ–±–∞–≤–∏—Ç—å –≤ –∏–∑–±—Ä–∞–Ω–Ω–æ–µ"

        buttons = []
        if show_full:
            buttons.append([
                InlineKeyboardButton(
                    text="–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç",
                    callback_data=MessageCallback(action="get_full", id=recipe_id).pack()
                )
            ])

        buttons.append([
            InlineKeyboardButton(
                text=favorite_text,
                callback_data=MessageCallback(action="toggle_favorite", id=recipe_id).pack()
            )
        ])

        return InlineKeyboardMarkup(inline_keyboard=buttons)
